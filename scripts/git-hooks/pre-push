#!/bin/bash

# Script de pre-push para OmniChat
# Este script se ejecuta automÃ¡ticamente antes de cada push para validar el cÃ³digo

echo "ðŸ” Ejecutando validaciones pre-push para OmniChat..."

# Colores para mensajes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

# FunciÃ³n para mostrar mensajes de error y salir
error_exit() {
    echo -e "${RED}âŒ ERROR: $1${NC}"
    exit 1
}

# FunciÃ³n para mostrar mensajes de advertencia
warning() {
    echo -e "${YELLOW}âš ï¸ ADVERTENCIA: $1${NC}"
}

# FunciÃ³n para mostrar mensajes de Ã©xito
success() {
    echo -e "${GREEN}âœ… $1${NC}"
}

# 1. Verificar que todos los tests pasen (si pytest estÃ¡ instalado)
echo "ðŸ§ª Verificando que todos los tests pasen..."

if command -v pytest &> /dev/null; then
    if [ -d "tests" ]; then
        echo "Ejecutando tests con pytest..."
        if ! pytest -xvs tests; then
            error_exit "Algunos tests fallaron. Por favor, corrige los tests antes de hacer push."
        fi
        success "Todos los tests pasaron."
    else
        warning "No se encontrÃ³ el directorio 'tests'. Considera aÃ±adir tests para tu proyecto."
    fi
else
    warning "pytest no estÃ¡ instalado. Considera instalarlo para ejecutar tests automÃ¡ticamente."
fi

# 2. Verificar que no haya claves API expuestas en el cÃ³digo
echo "ðŸ”‘ Verificando que no haya claves API expuestas en el cÃ³digo..."

# Patrones de claves API comunes
API_PATTERNS=(
    "sk-[a-zA-Z0-9]{48}" # OpenAI API key
    "r[a-zA-Z0-9]{32}" # Mistral API key
    "sk-or-v1-[a-zA-Z0-9]{64}" # OpenRouter API key
    "AIza[a-zA-Z0-9_-]{35}" # Google API key
    "tvly-[a-zA-Z0-9]{32}" # Tavily API key
    "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" # UUID format (Exa, YOU.com, etc.)
)

# Archivos a excluir de la verificaciÃ³n
EXCLUDE_FILES=(
    ".env"
    "*.env"
    ".streamlit/secrets.toml"
    "secrets.toml.example"
)

# Construir el patrÃ³n de exclusiÃ³n
EXCLUDE_PATTERN=$(printf "|%s" "${EXCLUDE_FILES[@]}")
EXCLUDE_PATTERN=${EXCLUDE_PATTERN:1}

# Obtener todos los archivos en el repositorio, excluyendo los archivos binarios y los archivos en la lista de exclusiÃ³n
FILES_TO_CHECK=$(git ls-files | grep -v -E "($EXCLUDE_PATTERN)" | xargs -I{} file --mime "{}" 2>/dev/null | grep -v "binary" | cut -d: -f1)

if [ -z "$FILES_TO_CHECK" ]; then
    success "No hay archivos para verificar."
else
    # Verificar cada patrÃ³n de API key en los archivos
    for PATTERN in "${API_PATTERNS[@]}"; do
        FOUND_FILES=$(grep -l -E "$PATTERN" $FILES_TO_CHECK 2>/dev/null || true)
        if [ ! -z "$FOUND_FILES" ]; then
            error_exit "Se encontraron posibles claves API expuestas en los siguientes archivos:\n$FOUND_FILES\n\nPor favor, mueve las claves API a .streamlit/secrets.toml o a variables de entorno."
        fi
    done
    success "No se encontraron claves API expuestas en el cÃ³digo."
fi

# 3. Verificar que requirements.txt estÃ© actualizado
echo "ðŸ“¦ Verificando que requirements.txt estÃ© actualizado..."

if [ -f "requirements.txt" ]; then
    # Verificar la fecha de modificaciÃ³n de requirements.txt
    REQUIREMENTS_MODIFIED=$(stat -f "%m" requirements.txt 2>/dev/null || stat -c "%Y" requirements.txt 2>/dev/null)

    # Verificar la fecha de modificaciÃ³n de los archivos Python
    PYTHON_FILES=$(git ls-files "*.py")
    NEWEST_PYTHON_FILE=$(ls -t $PYTHON_FILES 2>/dev/null | head -n 1)

    if [ ! -z "$NEWEST_PYTHON_FILE" ]; then
        PYTHON_MODIFIED=$(stat -f "%m" "$NEWEST_PYTHON_FILE" 2>/dev/null || stat -c "%Y" "$NEWEST_PYTHON_FILE" 2>/dev/null)

        if [ "$PYTHON_MODIFIED" -gt "$REQUIREMENTS_MODIFIED" ]; then
            warning "requirements.txt puede estar desactualizado. Considera actualizarlo con 'pip freeze > requirements.txt'."
        else
            success "requirements.txt parece estar actualizado."
        fi
    fi
else
    warning "No se encontrÃ³ el archivo requirements.txt. Considera crearlo para documentar las dependencias del proyecto."
fi

# 4. Verificar que README.md estÃ© actualizado
echo "ðŸ“ Verificando que README.md estÃ© actualizado..."

if [ -f "README.md" ]; then
    # Verificar la fecha de modificaciÃ³n de README.md
    README_MODIFIED=$(stat -f "%m" README.md 2>/dev/null || stat -c "%Y" README.md 2>/dev/null)

    # Verificar la fecha de modificaciÃ³n de los archivos Python
    PYTHON_FILES=$(git ls-files "*.py")
    NEWEST_PYTHON_FILE=$(ls -t $PYTHON_FILES 2>/dev/null | head -n 1)

    if [ ! -z "$NEWEST_PYTHON_FILE" ]; then
        PYTHON_MODIFIED=$(stat -f "%m" "$NEWEST_PYTHON_FILE" 2>/dev/null || stat -c "%Y" "$NEWEST_PYTHON_FILE" 2>/dev/null)

        if [ "$PYTHON_MODIFIED" -gt "$README_MODIFIED" ]; then
            warning "README.md puede estar desactualizado. Considera actualizarlo para reflejar los cambios recientes."
        else
            success "README.md parece estar actualizado."
        fi
    fi
else
    warning "No se encontrÃ³ el archivo README.md. Considera crearlo para documentar el proyecto."
fi

# Todas las validaciones pasaron
echo -e "${GREEN}âœ… Todas las validaciones pre-push pasaron exitosamente.${NC}"
exit 0
